import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as e,c as a,f as o}from"./app-M96zHdX9.js";const i={},n=o('<p>要知道MySQL索引底层数据结构为啥用B+树，先要了解一下什么样的数据结构更适合建索引。 为了保证数据安全性，一般都是把数据存储在磁盘里面。当我们需要查询数据的时候，需要读取磁盘，就产生了磁盘IO，相比较内存操作，磁盘IO读取速度是非常慢的。 由于所需数据可能在磁盘并不是连续的，一次数据查询就需要多次磁盘IO，所以就需要我们设计的索引数据结构尽可能的减少磁盘IO次数。 再了解一下这几种二叉树的特性，以及优缺点，就知道哪种数据结构更适合建索引。</p><h1 id="二叉搜索树" tabindex="-1"><a class="header-anchor" href="#二叉搜索树"><span>二叉搜索树</span></a></h1><p><strong>什么是二叉搜索树：</strong></p><ol><li>若左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>左、右子树也分别为二叉查找树； <img src="https://javabaguwen.com/img/二叉查找树.png" alt="image-1.png" loading="lazy"></li></ol><p>二叉搜索树查找数据的时间复杂度是O(logN)，如图所示，最多查找3次就可以查到所需数据。 理想很丰满，现实很骨感。极端情况下，二叉查找树可能退化成线性链表。</p><p>链表的查找时间复杂度是O(N)，这时候最多需要7次才能查到所需数据。 该怎么办呢？于是我们就想到了给二叉树加一些限制条件，平衡一下左右子树，然后就引申出了很多平衡树：平衡二叉查找树、红黑树、B树、B+树。咱们分别说一下这几种树的优缺点，看哪种树最适合做索引。</p><h1 id="红黑树" tabindex="-1"><a class="header-anchor" href="#红黑树"><span>红黑树</span></a></h1><p><strong>什么是红黑树？</strong></p><ol><li>结点是红色或黑色</li><li>根结点是黑色</li><li>所有叶子都是黑色（叶子是NIL结点）</li><li>每个红色结点的两个子结点都是黑色（从每个叶子到根的所有路径上不能有两个连续的红色结点）</li><li>从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点 <img src="https://javabaguwen.com/img/二叉查找树（特殊情况）.png" alt="image-2.png" loading="lazy"></li></ol><p>看蒙了没有？ 这么多复杂的规则，就是为了保证从根节点到叶子节点的最长路径不超过最短路径的2倍。 当插入节点或者删除节点的时候，为了满足红黑树规则，可能需要变色和旋转，这是一个复杂且耗时的过程。 <strong>红黑树的优点：</strong> 限制了左右子树的树高，不会相差过大。 <strong>缺点：</strong> 规则复杂，一般人想要弄懂这玩意儿，就已经很费劲了，更别说使用了。</p><h1 id="b树" tabindex="-1"><a class="header-anchor" href="#b树"><span>B树</span></a></h1><p><strong>什么是B树？</strong> 我们知道，树的高度越高，查找次数越多，也就是磁盘IO次数越多，耗时越长， 我们能不能想办法降低树的高度，把二叉树变成N叉树？于是B树就来了。</p><p><strong>对于一个m阶的B树：</strong></p><ol><li>根节点至少有2个子节点</li><li>每个中间节点都包含k-1个元素和k个子节点，其中 m/2 &lt;= k &lt;= m</li><li>每个叶子节点都包含k-1个元素，其中 m/2 &lt;= k &lt;= m</li><li>中间节点的元素按照升序排列</li><li>所有的叶子结点都位于同一层 <img src="https://javabaguwen.com/img/B树.png" alt="image-1.png" loading="lazy"></li></ol><p>根节点（8）有两个子节点，左子节点（3 5）和右子节点（11 15）。 左子节点（3 5）中有2个元素和3个子节点。 元素是3和5，按照升序排列。 子节点是（1 2）、（4）、（6 7）， 而（1 2）中元素小于3，（4）中的元素在3和5中间，（6 7）的元素大于5，符合B树特征。 B树这样的设计有哪些优点呢？ 高度更低，每个节点含有多个元素，查找的时候一次可以把一个节点中的所有元素加载到内存中作比较，两种改进都大大减少了磁盘IO次数。</p><h1 id="b-树" tabindex="-1"><a class="header-anchor" href="#b-树"><span>B+树</span></a></h1><p><strong>什么是B+树？</strong> 相比较B树，B+树又做了如下约定：</p><ol><li>有k个子节点的中间节点就有k个元素（B树中是k-1个元素），也就是子节点数量 = 元素数量。 每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。</li><li>所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。</li><li>非叶子节点只保存索引，不保存数据。（B树中两者都保存）</li><li>叶子结点包含了全部元素的信息，并且叶子结点按照元素大小组成有序列表。 <img src="https://javabaguwen.com/img/B%2B树.png" alt="image-1.png" loading="lazy"></li></ol><p>B+树这样设计有什么优点呢？</p><ol><li>每个节点存储的元素更多，看起来比B树更矮胖，导致磁盘IO次数更少。</li><li>非叶子节点不存储数据，只存储索引，叶子节点存储全部数据。 这样设计导致每次查找都会查到叶子节点，效率更稳定，便于做性能优化。</li><li>叶子节点之间使用有序链表连接。 这样设计方便范围查找，只需要遍历链表中相邻元素即可，不再需要二次遍历二叉树。</li></ol><p>很明显，B树和B+树就是为了文件检索系统设计的，更适合做索引结构。</p>',21),l=[n];function p(r,s){return e(),a("div",null,l)}const c=t(i,[["render",p],["__file","b.html.vue"]]),h=JSON.parse('{"path":"/mysql/b.html","title":"二叉搜索树","lang":"zh-CN","frontmatter":{"description":"要知道MySQL索引底层数据结构为啥用B+树，先要了解一下什么样的数据结构更适合建索引。 为了保证数据安全性，一般都是把数据存储在磁盘里面。当我们需要查询数据的时候，需要读取磁盘，就产生了磁盘IO，相比较内存操作，磁盘IO读取速度是非常慢的。 由于所需数据可能在磁盘并不是连续的，一次数据查询就需要多次磁盘IO，所以就需要我们设计的索引数据结构尽可能的减...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/mysql/b.html"}],["meta",{"property":"og:site_name","content":"Java八股文网"}],["meta",{"property":"og:title","content":"二叉搜索树"}],["meta",{"property":"og:description","content":"要知道MySQL索引底层数据结构为啥用B+树，先要了解一下什么样的数据结构更适合建索引。 为了保证数据安全性，一般都是把数据存储在磁盘里面。当我们需要查询数据的时候，需要读取磁盘，就产生了磁盘IO，相比较内存操作，磁盘IO读取速度是非常慢的。 由于所需数据可能在磁盘并不是连续的，一次数据查询就需要多次磁盘IO，所以就需要我们设计的索引数据结构尽可能的减..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://javabaguwen.com/img/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-05-14T15:32:21.000Z"}],["meta",{"property":"article:author","content":"Mr.Hope"}],["meta",{"property":"article:modified_time","content":"2024-05-14T15:32:21.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"二叉搜索树\\",\\"image\\":[\\"https://javabaguwen.com/img/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91.png\\",\\"https://javabaguwen.com/img/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%EF%BC%88%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5%EF%BC%89.png\\",\\"https://javabaguwen.com/img/B%E6%A0%91.png\\",\\"https://javabaguwen.com/img/B%2B%E6%A0%91.png\\"],\\"dateModified\\":\\"2024-05-14T15:32:21.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Hope\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[],"git":{"createdTime":1714793433000,"updatedTime":1715700741000,"contributors":[{"name":"Yideng","email":"oointer@163.com","commits":2}]},"readingTime":{"minutes":4.87,"words":1462},"filePathRelative":"mysql/b.md","localizedDate":"2024年5月4日","autoDesc":true}');export{c as comp,h as data};
