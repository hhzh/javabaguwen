import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as t,c as i,f as a}from"./app-uJW8EvoO.js";const n={},o=a('<p>MySQL InnoDB引擎在Repeatable Read（可重复读）隔离级别下，到底有没有解决幻读的问题？ 网上众说纷纭，有的说解决了，有的说没解决，甚至有些大v的意见都无法达成统一。 今天就深入剖析一下，彻底解决这个幻读的问题。 解决幻读问题之前，先普及几个知识点。</p><h2 id="_1-并发事务产生的问题" tabindex="-1"><a class="header-anchor" href="#_1-并发事务产生的问题"><span>1. 并发事务产生的问题</span></a></h2><p>先创建一张用户表，用作数据验证：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>CREATE TABLE `user` (\n  `id` int NOT NULL AUTO_INCREMENT COMMENT &#39;主键&#39;,\n  `name` varchar(100) DEFAULT NULL COMMENT &#39;姓名&#39;,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB COMMENT=&#39;用户表&#39;;\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>并发事务会产生下面三个问题：</p><h3 id="脏读" tabindex="-1"><a class="header-anchor" href="#脏读"><span>脏读</span></a></h3><p><strong>定义：</strong> 一个事务读到其他事务未提交的数据。 <img src="https://files.mdnice.com/user/33013/35741d2a-eb65-4eb9-aecd-6ebd4cb9f93c.png#id=Y81yT&amp;originHeight=932&amp;originWidth=1344&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="" loading="lazy"> 从上面的示例图中，可以看出，在事务2修改完数据，没有提交的情况。事务1已经读到事务2最新修改的数据，这种情况就属于脏读。</p><h3 id="不可重复读" tabindex="-1"><a class="header-anchor" href="#不可重复读"><span>不可重复读</span></a></h3><p><strong>定义：</strong> 一个事务读取到其他事务修改过的数据。 <img src="https://files.mdnice.com/user/33013/bd54ede9-1077-4eb5-8be0-9508aeeb4e85.png#id=Vyr90&amp;originHeight=934&amp;originWidth=1322&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="" loading="lazy"> 从上面的示例图中，可以看出，在事务2修改完数据，并提交事务后。事务1第二次查询已经读到事务2最新修改的数据，这种情况就属于不可重复读。</p><h3 id="幻读" tabindex="-1"><a class="header-anchor" href="#幻读"><span>幻读</span></a></h3><p><strong>定义：</strong> 一个事务读取到其他事务最新插入的数据。 <img src="https://files.mdnice.com/user/33013/e2396364-149c-4a4f-bccc-2f46d86dfc45.png#id=R9gJa&amp;originHeight=984&amp;originWidth=1318&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="" loading="lazy"> 从上面的示例图中，可以看出，在事务2插入完数据，并提交事务后。事务1第二次查询已经读到事务2最新插入的数据，这种情况就属于幻读。</p><h2 id="_2-快照读和当前读" tabindex="-1"><a class="header-anchor" href="#_2-快照读和当前读"><span>2. 快照读和当前读</span></a></h2><p>再普及一下快照读和当前读。 <strong>快照读：</strong> 读取数据的历史版本，不对数据加锁。 例如：select</p><p><strong>当前读：</strong> 读取数据的最新版本，并对数据进行加锁。 例如：insert、update、delete、select for update、select lock in share mode。</p><h2 id="_3-再谈幻读问题" tabindex="-1"><a class="header-anchor" href="#_3-再谈幻读问题"><span>3. 再谈幻读问题</span></a></h2><p>MySQL在<strong>Repeatable Read（可重复读）<strong>隔离级别下，到底有没有解决</strong>幻读</strong>的问题？ 只能说是部分解决了<strong>幻读</strong>问题。 首先，在快照读的情况下，是通过<strong>MVCC（复用读视图）<strong>解决了幻读问题。 想详细了解MVCC和读视图，可以翻一下上篇文章。 先手动设置一下MySQL的隔离级别为</strong>可重复读</strong>：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><img src="https://files.mdnice.com/user/33013/15adb8fa-119e-4600-b7e7-b1c69980ff02.png#id=thuNr&amp;originHeight=332&amp;originWidth=934&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="" loading="lazy"> 执行测试用例，验证一下： <img src="https://files.mdnice.com/user/33013/d77972ff-f285-427d-9a63-019c84bec5bd.png#id=Wdbgs&amp;originHeight=938&amp;originWidth=1296&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="" loading="lazy"> 从上面的示例图中，可以看出，事务1的两次查询，得到的结果一致，并没有查到事务2最新插入的数据。 原因是，在可重复读隔离级别下，第一次快照读的时候，生成了一个读视图。第二次快照读的时候，复用了第一次生成的读视图，所以两次查询得到的结果一致。 所以，在快照读的情况下，<strong>可重复读</strong>隔离级别是解决了<strong>幻读</strong>的问题。 再测试一下，在<strong>当前读</strong>的情况下，<strong>可重复读</strong>隔离级别是否解决<strong>幻读</strong>问题：</p><p><img src="https://files.mdnice.com/user/33013/a8c35298-aa68-4b06-94dd-29c51d1d5d2e.png#id=CeUg5&amp;originHeight=952&amp;originWidth=1570&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="" loading="lazy"> 从上面的示例图中，可以看出，事务1的两次查询，得到的结果不一致。在事务2插入数据，并提交事务后。事务1的第二次执行<strong>当前读（加了for update）<strong>的时候，读到了事务2最新插入的数据。 原因是，在可重复读隔离级别下，每次执行当前读会生成一个新的</strong>读视图</strong>，所以能读到其他事务最新插入的数据。 所以，在<strong>当前读</strong>的情况下，<strong>可重复读</strong>隔离级别是没有解决了<strong>幻读</strong>的问题。</p><p>在执行上面的测试用例的时候，我忽然想到一个问题，既然select for update的当前读，出现了幻读问题，是不是其他的当前读也会复现幻读问题，比如insert。 再执行测试用例，验证一下：</p><p><img src="https://files.mdnice.com/user/33013/4984749e-431b-40fa-a2b5-96371c8de780.png#id=WeM0B&amp;originHeight=888&amp;originWidth=1544&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="" loading="lazy"> 跟预想的一样，在insert当前读的情况下，也出现了幻读的问题（主键冲突）。 那有没有什么办法？在<strong>可重复读</strong>隔离级别下，执行<strong>当前读</strong>的时候，也能解<strong>决幻读</strong>的问题？ 当然有的，唯一的办法就是<strong>加锁</strong>。 <img src="https://files.mdnice.com/user/33013/6dcdf7eb-55c2-497c-a2db-e34f5f444ea3.png#id=D60CV&amp;originHeight=746&amp;originWidth=1562&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="" loading="lazy"> 事务1在执行第一次查询的时候，就对数据进行加锁（使用for update），防止其他事务修改数据，这样也就彻底解决了<strong>幻读</strong>问题。 你觉得有什么好办法吗？</p>',21),s=[o];function r(l,p){return t(),i("div",null,s)}const m=e(n,[["render",r],["__file","phantom.html.vue"]]),c=JSON.parse('{"path":"/mysql/phantom.html","title":"","lang":"zh-CN","frontmatter":{"description":"MySQL InnoDB引擎在Repeatable Read（可重复读）隔离级别下，到底有没有解决幻读的问题？ 网上众说纷纭，有的说解决了，有的说没解决，甚至有些大v的意见都无法达成统一。 今天就深入剖析一下，彻底解决这个幻读的问题。 解决幻读问题之前，先普及几个知识点。 1. 并发事务产生的问题 先创建一张用户表，用作数据验证： 并发事务会产生下面三...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/mysql/phantom.html"}],["meta",{"property":"og:site_name","content":"Java八股文网"}],["meta",{"property":"og:description","content":"MySQL InnoDB引擎在Repeatable Read（可重复读）隔离级别下，到底有没有解决幻读的问题？ 网上众说纷纭，有的说解决了，有的说没解决，甚至有些大v的意见都无法达成统一。 今天就深入剖析一下，彻底解决这个幻读的问题。 解决幻读问题之前，先普及几个知识点。 1. 并发事务产生的问题 先创建一张用户表，用作数据验证： 并发事务会产生下面三..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://files.mdnice.com/user/33013/35741d2a-eb65-4eb9-aecd-6ebd4cb9f93c.png#id=Y81yT&originHeight=932&originWidth=1344&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"Mr.Hope"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"https://files.mdnice.com/user/33013/35741d2a-eb65-4eb9-aecd-6ebd4cb9f93c.png#id=Y81yT&originHeight=932&originWidth=1344&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=\\",\\"https://files.mdnice.com/user/33013/bd54ede9-1077-4eb5-8be0-9508aeeb4e85.png#id=Vyr90&originHeight=934&originWidth=1322&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=\\",\\"https://files.mdnice.com/user/33013/e2396364-149c-4a4f-bccc-2f46d86dfc45.png#id=R9gJa&originHeight=984&originWidth=1318&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=\\",\\"https://files.mdnice.com/user/33013/15adb8fa-119e-4600-b7e7-b1c69980ff02.png#id=thuNr&originHeight=332&originWidth=934&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=\\",\\"https://files.mdnice.com/user/33013/d77972ff-f285-427d-9a63-019c84bec5bd.png#id=Wdbgs&originHeight=938&originWidth=1296&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=\\",\\"https://files.mdnice.com/user/33013/a8c35298-aa68-4b06-94dd-29c51d1d5d2e.png#id=CeUg5&originHeight=952&originWidth=1570&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=\\",\\"https://files.mdnice.com/user/33013/4984749e-431b-40fa-a2b5-96371c8de780.png#id=WeM0B&originHeight=888&originWidth=1544&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=\\",\\"https://files.mdnice.com/user/33013/6dcdf7eb-55c2-497c-a2db-e34f5f444ea3.png#id=D60CV&originHeight=746&originWidth=1562&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Hope\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"1. 并发事务产生的问题","slug":"_1-并发事务产生的问题","link":"#_1-并发事务产生的问题","children":[{"level":3,"title":"脏读","slug":"脏读","link":"#脏读","children":[]},{"level":3,"title":"不可重复读","slug":"不可重复读","link":"#不可重复读","children":[]},{"level":3,"title":"幻读","slug":"幻读","link":"#幻读","children":[]}]},{"level":2,"title":"2. 快照读和当前读","slug":"_2-快照读和当前读","link":"#_2-快照读和当前读","children":[]},{"level":2,"title":"3. 再谈幻读问题","slug":"_3-再谈幻读问题","link":"#_3-再谈幻读问题","children":[]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":4.39,"words":1316},"filePathRelative":"mysql/phantom.md","autoDesc":true}');export{m as comp,c as data};
